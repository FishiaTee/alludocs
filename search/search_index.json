{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to alludocs!","text":"<p>alludocs is a small project aiming to document various bits of Allumeria in order to assist in modding the game!</p> <p>It is written partially based on information from one of my GitHub Gists.</p> <p>Note</p> <p>This wiki is incomplete, and was written based on limited knowledge of the game's codebase. It is intended to purely assist in modding efforts. Due to the game's nature as an in-development game, things could change unexpectedly.</p> <p>Version Alpha 0.7.2 was used in most parts of this wiki as of July 3rd, 2025.</p> <p>Contributions are welcome. </p>"},{"location":"items/advanced/","title":"Advanced Items","text":""},{"location":"items/advanced/#the-item-class","title":"The Item class","text":"<p>The base Item instance will suffice for basic item types such as food or tools, however to have more advanced behavior, you have to make your own extended Item class.</p> <p>The basic of this is having your very own Item class, and overriding its defaults with your own. This may also be referred to as polymorphism. </p> <p>The base Item class provide many virtual methods, which get triggered when certain actions are done in-game (e.g., left click, right click, etc...); however by default, those virtual methods are empty. By having another class inheriting the base Item class, we can override those default virtual methods and having them run our custom code.</p> <p>Info</p> <p>Virtual methods are methods that allow itself to be overriden by any class that inherits it.</p> <p>For example:</p> <pre><code>public class TestOne {\n    public virtual void Message() {\n        Console.WriteLine(\"Hello, world!\");\n    }\n}\n</code></pre> <p>When we do <code>TestOne.Message()</code>, the message \"Hello, world!\" would be printed to the console. However, what if instead of \"Hello, world!\", we want to print \"Goodbye, world!\" instead?</p> <pre><code>// The new class TestTwo inherits TestOne, which allows us to override Message()\npublic class TestTwo : TestOne {\n    // Override\n    public override void Message() {\n        // Our new code\n        Console.WriteLine(\"Goodbye, world!\");\n    }\n}\n</code></pre> <p>Now if we do <code>TestTwo.Message()</code>, the message \"Goodbye, world!\" would be printed to the console!</p> <p>If you want to run both your new code and the original one, you can do so like this:</p> <pre><code>public class TestTwo : TestOne {\n    public override void Message() {\n        // Run our new code\n        Console.WriteLine(\"Goodbye, world!\");\n        // And now run the original\n        base.Message();\n    }\n}\n</code></pre> <p>After executing, our new text \"Goodbye, world!\" will be printed first, and then the original \"Hello, world!\"</p>"},{"location":"items/advanced/#events","title":"\"Events\"","text":"<p>Events are a way of referring to the virtual methods provided by the base Item class. They are called so because such virtual methods only get executed when something triggers it.</p> Method Description <code>void OnUse(PlayerEntity player, World world)</code> When the Player right clicks. <code>void OnLeftClickUse(PlayerEntity player, World world)</code> When the Player left clicks. <code>void ReleaseLeft(PlayerEntity player, World world)</code> When the Player release left mouse. <code>void OnHeldDownTick(PlayerEntity player, World world)</code> When the Player hold down either left or right mouse. <code>void OnHeldTick(PlayerEntity player, World world)</code> When the Player select the Item in the hotbar. <code>void ReleaseRight(PlayerEntity player, World world)</code> When the Player release right mouse. <code>void OnRadialClose(PlayerEntity player, int selection)</code> When the Radial menu is closed. <code>void OnRadialOpen(PlayerEntity player, UIRadialMenu menu)</code> When the Radial menu is opened. <code>bool AllowedInSlot(InventorySlot slot)</code> Used to perform special inventory slot checks (e.g., Trinket) <code>void LoadAssets()</code> Used to load additional assets (e.g., sounds) <code>bool CanConsume(PlayerEntity player)</code> Whether or not the player can consume the Item. <code>void OnHitEntity(PlayerEntity player, Entity entity)</code> When the Player hits an Entity."},{"location":"items/advanced/#examples","title":"Example(s)","text":"Example<pre><code>class CustomItem : Item\n{\n    public CustomItem(int x, int y, string stringId) : base(x, y, stringId) {\n    }\n\n    public override void OnUse(PlayerEntity player, World world) {\n        // Run the original virtual method\n        base.OnUse(player, world);\n        // Print \"Hello, world!\" to chat log\n        ChatLog.PushFromPlayer(\"Hello, world!\");\n    }\n}\n</code></pre> <p>The above example is an Item that upon use, will print a chat message \"Hello, world!\". After writing your custom Item class, register your Item using said class.</p> Example<pre><code>Item helloWorldItem = new CustomItem(0, 16, \"hello_world_item\");\n</code></pre>"},{"location":"items/items/","title":"Items","text":"<p>Items are internally identified via numeric IDs, and are registered by instantiating a new Item instance.</p> <pre><code>Item item = new Item(int x, int y, str stringId);\n</code></pre> <p>An Item takes three basic arguments: texture coordinates (X and Y) and a string identifier. The string identifier is used to refererence the Item in various places (e.g., translations).</p>"},{"location":"items/items/#texture","title":"Texture","text":"<p>All items textures are stored in a single 1024x1024 texture atlas. Each textures are 16x16 in size, so the atlas consists of 64 rows and 64 columns, giving us a total of 4096 available texture slots.</p> <p>You can access the texture atlas in <code>res/textures/items.png</code>.</p> <p>When registering a new Item, you assign a texture to said Item by specifying its X and Y coordinates, which is the row and the column number multiplied by 16.</p>"},{"location":"items/items/#3d-model","title":"3D Model","text":"<p>An Item can have a 3D hand model, which will be displayed when the player hold the Item in their hotbar slot.</p> <p>With an Item instance, a 3D model can be assigned with:</p> <pre><code>Item.SetModel(str model, str texture);\n</code></pre> <p>The game takes models from <code>res/models</code> and textures from <code>res/textures</code>. Basically, a 3D model consists of two elements: the shape (model) and the texture.</p> Example<pre><code>// Register the item\nItem obsidian_sword = new Item(0, 144, \"obsidian_sword\");\n// Set a 3D hand model\nobsidian_sword.SetModel(\"item.sword\", \"item.obsidian_sword\");\n</code></pre> <p>We use the <code>sword</code> base model from <code>res/models/item/sword.json</code>, and apply our texture from <code>res/textures/item/obsidian_sword.png</code>.</p>"},{"location":"items/items/#stack-size","title":"Stack Size","text":"<p>All items by default can be stacked up to 512. This can be overriden with:</p> <pre><code>Item.SetStackSize(int stack);\n</code></pre>"},{"location":"items/items/#tags","title":"Tags","text":"<p>To change an Item's properties, we use Tags.</p> <p>By adding a Tag, you are adding a TagEntry.</p> <pre><code>Item.AddTag(ItemTagEntry tagEntry);\n</code></pre> <p>A TagEntry consists of a Tag, and its integer value. All tags have a value assigned to it, and this value determines the effectiveness of said tags.</p> <pre><code>ItemTagEntry tag = new ItemTagEntry(ItemTag tag, int value);\n</code></pre> Example<pre><code>// Register the item\nItem cool_pickaxe = new Item(16, 192, \"obsidian_sword\");\n// Assign it a tag (pickaxe power)\ncool_pickaxe.AddTag(new ItemTagEntry(ItemTag.pickaxe, 8));\n</code></pre> <p>In the above example, we assigned a Tag (<code>ItemTag.pickaxe</code>) which in turns assigns the Item <code>cool_pickaxe</code> a pickaxe power of 8.</p> <p>Tags are powerful, and can be used to do various things. More information about it can be found in its dedicated Tags section.</p>"},{"location":"items/items/#translations","title":"Translations","text":"<p>For an Item to have a proper localized name, it is necessary to add a translation entry for it.</p> <p>To do so, add an entry to <code>res/translations/en_au.txt</code>.</p> <pre><code>item.&lt;string ID&gt; &lt;localized name&gt;\n</code></pre> <p>If you want your Item to have a description, add another entry.</p> <pre><code>item.&lt;string ID&gt;.desc &lt;description&gt;\n</code></pre> Example<pre><code>item.cool_pickaxe Cool Pickaxe\nitem.obsidian_sword Obsidian Sword\nitem.obsidian_sword.desc The most powerful sword in the game.\n</code></pre>"},{"location":"items/items/#advanced-behavior","title":"Advanced Behavior","text":"<p>Using basic Item registration and only the default tags could only get you so far, for more advanced items please see its own dedicated section.</p>"},{"location":"items/tags/","title":"More about Tags","text":""},{"location":"items/tags/#adding-a-new-tag","title":"Adding a new Tag","text":"<p>Tag are similar to Item in the sense that registration is done through instantiating a new Tag instance.</p> <pre><code>ItemTag tag = new ItemTag(str tagId, bool isHidden = false, bool hasIcon = false, int x, int y);\n</code></pre> <ul> <li><code>tagId</code>: the string identifier of the Tag</li> <li><code>isHidden</code>: whether or not the Tag will be shown in the Item tooltip</li> <li><code>hasIcon</code>: whether or not the Tag have an icon, won't be shown if <code>isHidden</code> is false</li> <li><code>x</code> and <code>y</code>: texture coordinates (X and Y) of the Tag icon</li> </ul> <p>A Tag can have an icon, which similarly to Item is also stored in a texture atlas (<code>res/textures/ui.png</code>).</p>"},{"location":"items/tags/#default-tags","title":"Default tags","text":"<p>The game has quite a few set of default tags for various properties.</p> String ID Internal Description can_place <code>ItemTag.can_place</code> Used for Block, determine whether or not the Item can be placed. can_consume <code>ItemTag.can_consume</code> Whether or not the Item is a consumable. cant_mine <code>ItemTag.cant_mine</code> Whether or not the Item can be used to mine Block. axe_power <code>ItemTag.axe</code> Whether or not the Item is an axe, and the power of it. hammer <code>ItemTag.hammer</code> Whether or not the Item is a hammer. melee_damage <code>ItemTag.melee_damage</code> The melee damage of the Item. pickaxe_power <code>ItemTag.pickaxe</code> Whether or not the Item is a pickaxe, and the power of it. swing_speed <code>ItemTag.swing_speed</code> The swing/usage cooldown of the Item. restores_health <code>ItemTag.restores_health</code> How much health is restored upon Item consumption. defence <code>ItemTag.defence</code> Used for Armor, how much defense is granted to the Player when wearing the Item. required_ammo <code>ItemTag.required_ammo</code> Whether or not the Item requires Ammo. ammo <code>ItemTag.ammo</code> Whether or not the Item is an Ammo. ranged_damage <code>ItemTag.ranged_damage</code> The ranged damage of the Item. trinket <code>ItemTag.trinket</code> Whether or not the Item is a Trinket."}]}